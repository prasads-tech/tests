import os
import json
import copy
import argparse
import logging
from dotenv import load_dotenv
import yaml

# Load environment variables from .env file
load_dotenv()

# Get paths from environment variables
input_file = os.getenv("INPUT_PATH")
mapping_file = os.getenv("MAPPING_PATH")
template_file = os.getenv("TEMPLATE_PATH")
output_dir = os.getenv("OUTPUT_DIR")

logging.basicConfig(level=logging.INFO)

def load_json(file_path: str) -> dict:
    """Loads JSON data from a file."""
    try:
        with open(file_path, "r", encoding="utf-8") as file:
            return json.load(file)
    except (FileNotFoundError, json.JSONDecodeError) as e:
        logging.error("Error loading %s JSON file with %s", file_path, e)
        raise

def validate_and_apply_defaults(mapping: dict, inputs: dict) -> tuple:
    """Validates input values based on the mapping and applies defaults."""
    validated_data = {}

    # Validate and apply defaults for common fields
    for key, properties in mapping.get("common", {}).items():
        value = inputs.get(key, None)
        if properties["required"] and value is None:
            raise ValueError(f"Mandatory field '{key}' is missing.")
        validated_data[key] = value if value is not None else properties["default"]

    # Validate and apply defaults for manifest-specific fields
    manifests_data = {}
    if "manifests" in mapping:
        for manifest, fields in mapping["manifests"].items():
            manifest_data = {}
            for key, properties in fields.items():
                value = inputs.get(key, None)
                if properties["required"] and value is None:
                    raise ValueError(
                        f"Mandatory field '{key}' for manifest '{manifest}' is missing."
                    )
                manifest_data[key] = value if value is not None else properties["default"]
            # Store fields directly for replacement
            manifests_data.update(manifest_data)

    return validated_data, manifests_data

def replace_placeholders(yaml_content, replacements):
    """Replaces placeholders in the YAML content with actual values."""
    if isinstance(yaml_content, dict):
        return {
            k: replace_placeholders(v, replacements) for k, v in yaml_content.items()
        }
    if isinstance(yaml_content, list):
        return [replace_placeholders(i, replacements) for i in yaml_content]
    if isinstance(yaml_content, str):
        for key, value in replacements.items():
            placeholder = f"${{{key}}}"
            if placeholder in yaml_content:
                yaml_content = yaml_content.replace(placeholder, str(value))
                # logging.info("Replacing %s with %s", placeholder, value)
        return yaml_content
    return yaml_content

def update_yaml_manifest(
    yaml_template: str, validated_data: dict, manifests_data: dict
) -> str:
    """Updates the YAML manifest with the validated input values."""
    # Load all YAML documents from the template
    yaml_docs = yaml.safe_load_all(yaml_template)

    # Prepare a list to store the updated documents
    updated_docs = []

    for doc in yaml_docs:
        # Make a deep copy of the current document to avoid modifying the original template
        updated_doc = copy.deepcopy(doc)

        # Combine validated_data and document-specific manifest data
        replacements = validated_data.copy()
        replacements.update(manifests_data)

        # Replace placeholders in the copied document
        updated_doc = replace_placeholders(updated_doc, replacements)

        # Add the updated document to the list
        updated_docs.append(updated_doc)

    # Combine all updated documents into a single string
    updated_yaml = "\n---\n".join([yaml.safe_dump(doc) for doc in updated_docs])

    return updated_yaml

def generate_output(validated_data):
    """Dynamically generate output filename based on input JSON data."""
    cluster_name = validated_data.get("CLUSTER_NAME")
    # environment = validated_data.get("ENV_NAME")
    base_output_dir = os.getenv("OUTPUT_DIR")

    # Define the output directory path
    output_dirs = os.path.join(base_output_dir, f"{cluster_name}")
    # Ensure the output directory exists
    os.makedirs(output_dirs, exist_ok=True)

    # Define the required folders to be created
    required_folders = ["namespaces", "config", "rbac", "network"]

    # Iterate through required folders to create them and add a sample text file
    for folder in required_folders:
        destination_folder = os.path.join(output_dirs, folder)
        # Create the directory if it doesn't exist
        os.makedirs(destination_folder, exist_ok=True)

        # Add a sample text file inside the created folder
        sample_file_path = os.path.join(destination_folder, "README.md")
        with open(sample_file_path, "w", encoding="utf-8") as sample_file:
            sample_file.write(f"This is a sample file for {folder}.")

    # Define the output file name inside the output directory
    output_file_name = f"{cluster_name}.yaml"
    output_file_path = os.path.join(output_dirs, output_file_name)

    # Return the correct output path
    return output_file_path

def main():
    """Main function to run the program."""
    # Parse command-line arguments
    parser = argparse.ArgumentParser(
        description="Generate Kubernetes cluster definitions from templates."
    )
    parser.add_argument("--input", required=True, help="Path to the input JSON file")
    parser.add_argument(
        "--mapping", required=True, help="Path to the mapping JSON file"
    )
    parser.add_argument(
        "--template", required=True, help="Path to the YAML template file"
    )

    args = parser.parse_args()

    # Load the mapping and input data
    mapping = load_json(args.mapping)
    inputs = load_json(args.input)

    # Validate inputs and apply defaults
    validated_data, manifests_data = validate_and_apply_defaults(mapping, inputs)

    # Debugging output
    # logging.info("Validated Data: %s", validated_data)
    # logging.info("Manifests Data: %s", manifests_data)

    # Load the YAML template
    with open(args.template, "r", encoding="utf-8") as yaml_file:
        yaml_template = yaml_file.read()

    # Update the YAML template with validated values
    updated_yaml = update_yaml_manifest(yaml_template, validated_data, manifests_data)

    # output_exists(output_dir)
    output_file_path = generate_output(validated_data)

    # Save the updated YAML manifest
    with open(output_file_path, "w", encoding="utf-8") as updated_yaml_file:
        updated_yaml_file.write(updated_yaml)

    logging.info("Cluster definition saved to '%s'.", output_file_path)

if __name__ == "__main__":
    main()
